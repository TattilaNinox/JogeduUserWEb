# User Bundle Optimaliz√°ci√≥s √©s Refaktor√°l√°si Terv üöÄ
## (SUBCOLLECTION + INFINITE SCROLL + TELJES SPECIFIK√ÅCI√ì)

## üéØ C√©lkit≈±z√©s
A felhaszn√°l√≥i k√∂tegek kezel√©s√©nek √°talak√≠t√°sa a maxim√°lis sk√°l√°zhat√≥s√°g (7000+ felhaszn√°l√≥, 1200+ jegyzet), szerveroldali sz≈±r√©s √©s hat√©kony adathozz√°f√©r√©s (Pagination) t√°mogat√°sa √©rdek√©ben.

---

## üõ† √öj Architekt√∫ra: Subcollection + Infinite Scroll

Az elemeket (`UserBundleItem`) al-kollekci√≥ban t√°roljuk, √©s 'Infinite Scroll' technik√°val t√∂ltj√ºk be 20-as√°val.

---

## üì¶ 1. Adatmodellek

### 1.1 UserBundle (Sz√ºl≈ë dokumentum)
**Firestore √∫tvonal:** `users/{uid}/bundles/{bundleId}`

```dart
class UserBundle {
  final String id;
  final String name;
  final String description;
  final DateTime createdAt;
  final DateTime modifiedAt;
  
  // Aggreg√°lt sz√°ml√°l√≥k (t√≠pusonk√©nt)
  final int totalCount;
  final int noteCount;
  final int jogesetCount;
  final int dialogusCount;
  final int allomasCount;
  
  // Firestore konverzi√≥k
  factory UserBundle.fromFirestore(DocumentSnapshot doc);
  Map<String, dynamic> toFirestore();
}
```

### 1.2 UserBundleItem (Al-kollekci√≥ dokumentum)
**Firestore √∫tvonal:** `users/{uid}/bundles/{bundleId}/items/{itemId}`

```dart
class UserBundleItem {
  final String id;           // Subcollection doc ID
  final String originalId;   // Eredeti jegyzet/jogeset ID
  final String originalCollection; // 'notes', 'jogesetek', 'dialogus_fajlok', 'memoriapalota_allomasok'
  
  // Denormaliz√°lt metaadatok (list√°z√°shoz, sz≈±r√©shez)
  final String title;
  final String type;         // 'text', 'deck', 'interactive', 'dynamic_quiz', 'jogeset', 'dialogus', 'allomas'
  final String? science;     // Pl. 'Polg√°ri jog'
  final String? category;    // Pl. 'Tulajdonjog'
  final List<String> tags;   // C√≠mk√©k
  final String? status;      // 'active', 'draft', stb.
  
  // Rendez√©shez
  final DateTime addedAt;    // K√∂teghez ad√°s id≈ëpontja
  
  // Firestore konverzi√≥k
  factory UserBundleItem.fromFirestore(DocumentSnapshot doc);
  Map<String, dynamic> toFirestore();
}
```

---

## ‚öôÔ∏è 2. Service R√©teg (`UserBundleService`)

```dart
class UserBundleService {
  // --- BUNDLE CRUD ---
  Stream<List<UserBundle>> getUserBundles(String userId);
  Future<UserBundle?> getBundle(String userId, String bundleId);
  Future<String> createBundle(String userId, UserBundle bundle);
  Future<void> updateBundle(String userId, UserBundle bundle);
  Future<void> deleteBundle(String userId, String bundleId);
  
  // --- ITEM CRUD (Subcollection) ---
  Future<List<UserBundleItem>> getItems(
    String userId,
    String bundleId, {
    DocumentSnapshot? lastDocument,
    int limit = 20,
    String? scienceFilter,
    String? typeFilter,
    String? tagFilter, // array-contains
  });
  
  Future<void> addItemToBundle(
    String userId,
    String bundleId,
    String originalId,
    String originalCollection,
  ); // Lek√©ri a metaadatokat, l√©trehozza az itemet, n√∂veli a sz√°ml√°l√≥t (Transaction)
  
  Future<void> removeItemFromBundle(
    String userId,
    String bundleId,
    String itemId,
    String itemType,
  ); // T√∂rli az itemet, cs√∂kkenti a sz√°ml√°l√≥t (Transaction)
  
  // --- LAZY CLEANUP ---
  Future<void> cleanupInvalidItem(
    String userId,
    String bundleId,
    UserBundleItem item,
  ); // Ha az eredeti elem m√°r nem l√©tezik
}
```

---

## üóÇÔ∏è 3. Firestore Indexek

A hat√©kony szerveroldali sz≈±r√©shez √∂sszetett indexekre van sz√ºks√©g.

**F√°jl:** `firestore.indexes.json` (hozz√°adand√≥)

```json
{
  "indexes": [
    {
      "collectionGroup": "items",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "science", "order": "ASCENDING" },
        { "fieldPath": "addedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "items",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "addedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "items",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tags", "arrayConfig": "CONTAINS" },
        { "fieldPath": "addedAt", "order": "DESCENDING" }
      ]
    }
  ]
}
```

---

## üßπ 4. Lazy Cleanup (T√∂r√∂lt Elemek Kezel√©se)

**Probl√©ma:** Ha egy jegyzet (az eredeti `notes` kollekci√≥ban) t√∂rl≈ëdik, a k√∂tegben a hivatkoz√°s √©s a metaadat megmarad.

**Megold√°s (Lazy / Lusta takar√≠t√°s):**
1. A felhaszn√°l√≥ a k√∂tegben l√°tja az elemet (az elt√°rolt c√≠mmel).
2. Kattint r√°, hogy megnyissa.
3. A rendszer megpr√≥b√°lja lek√©rni az eredeti dokumentumot az `originalCollection`-b≈ël.
4. Ha a dokumentum **nem l√©tezik** (404):
   - Megjelen√≠t egy √ºzenetet: "Ez az elem m√°r nem el√©rhet≈ë."
   - Automatikusan megh√≠vja a `cleanupInvalidItem` met√≥dust.
   - Ez t√∂rli az itemet a subcollection-b≈ël √©s cs√∂kkenti a sz√°ml√°l√≥t.
5. A lista friss√ºl.

**El≈ëny:** Nincs sz√ºks√©g k√∂lts√©ges h√°tt√©rfolyamatokra (Cloud Functions) a szinkroniz√°l√°shoz.


---

## üì∫ 5. Infinite Scroll Implement√°ci√≥ (UI)


A `UserBundleViewScreen`-ben:

```dart
class _UserBundleViewScreenState extends State<UserBundleViewScreen> {
  final _scrollController = ScrollController();
  final List<UserBundleItem> _items = [];
  DocumentSnapshot? _lastDocument;
  bool _isLoadingMore = false;
  bool _hasMore = true;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_scrollListener);
    _loadInitialItems();
  }

  void _scrollListener() {
    if (_scrollController.position.pixels >= 
        _scrollController.position.maxScrollExtent - 200) {
      _loadMoreItems();
    }
  }

  Future<void> _loadInitialItems() async {
    final result = await UserBundleService.getItems(...);
    setState(() {
      _items.addAll(result.items);
      _lastDocument = result.lastDoc;
      _hasMore = result.items.length == 20;
    });
  }

  Future<void> _loadMoreItems() async {
    if (_isLoadingMore || !_hasMore) return;
    setState(() => _isLoadingMore = true);
    
    final result = await UserBundleService.getItems(
      ..., lastDocument: _lastDocument,
    );
    
    setState(() {
      _items.addAll(result.items);
      _lastDocument = result.lastDoc;
      _hasMore = result.items.length == 20;
      _isLoadingMore = false;
    });
  }
  
  // ...
}
```

---

## üìã 6. Implement√°ci√≥s Sorrend

1. **Modellek:** `lib/models/user_bundle.dart`, `lib/models/user_bundle_item.dart`
2. **Service:** `lib/services/user_bundle_service.dart`
3. **Indexek:** `firestore.indexes.json` friss√≠t√©se
4. **UI √Åt√≠r√°s:**
   - `UserBundleViewScreen` (Infinite Scroll)
   - `UserBundleEditScreen` (Service haszn√°lat)
   - `UserBundleListScreen` (Stream)
   - `DocumentSelectionScreen` (Item hozz√°ad√°s a service-en kereszt√ºl)
5. **Tesztel√©s:** √öj k√∂tegek l√©trehoz√°sa √©s elemek hozz√°ad√°sa

---

## üí∞ 7. K√∂lts√©g √©s Teljes√≠tm√©ny √ñsszefoglal√≥

| M≈±velet | R√©gi (N+1) | √öj (Subcollection) | Megtakar√≠t√°s |
|---------|------------|---------------------|--------------|
| 100 elemes k√∂teg megnyit√°s | 101 olvas√°s | 21 olvas√°s | ~80% |
| Sz≈±r√©s 5 tal√°latra | 101 olvas√°s | 5 olvas√°s | ~95% |
| Elem hozz√°ad√°sa | 1 √≠r√°s | 2 √≠r√°s (item + counter) | - |

A megold√°s rendk√≠v√ºl k√∂lts√©ghat√©kony √©s felhaszn√°l√≥bar√°t (gyors bet√∂lt√©s, szerveroldali sz≈±r√©s).
